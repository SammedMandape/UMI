# -*- coding: utf-8 -*-
"""
Author: Sammed Mandape
Purpose: This python code will extract UMI, DNA fragment containing STR, and 
primer, from read1 and read2 of the fastq files data generated by using QIAseq
DNA panel.
"""

import os
import re
import collections
import strfuzzy


#remember to change directory where all the fastq files are located
directory = "/data"
os.chdir(directory)

complement = {'A' : 'T', 'C' : 'G', 'T' : 'A', 'G' : 'C'}

def reverse_complement(seq):
    '''
    This function gives out a reverse complement of sequence
    @param seq - type of str 
        The input seqeunce to construct a reverse complement of
                
    @return bases - type of str
        Reverse complement of input sequence
    '''
    bases = list(seq)
    bases = ''.join(complement[base] for base in reversed(bases))
    return bases

def getFastqNameR1R2(directory):
    '''
    It creates a dictionary of fastq filenames available in a directory. 
    @param directory - type of str
        Name of directory where all the fastq files are located
        
    @retun filedict - type of dict
        Dictionary of filenames where key is read1 and value is its respective
        pair of read2
    '''
    filedict = {}
    for filename in os.listdir(directory):
        if filename.endswith("001.fastq"):
            #if re.match(r'\d+-\d+_.*_R1_\d+\.fastq', filename) is not None:
            filebegin = re.match(r'(\d+-\d+_.*)_R1_(\d+\.fastq)', filename)
            if filebegin is not None:
                filebeginr1 = filebegin.group(1) + "_R1_001.fastq"
                filebeginr2 = filebegin.group(1) + "_R2_001.fastq"
                filedict[filebeginr1] = filebeginr2
    return filedict

filedict = getFastqNameR1R2(directory)


def dict_for_primer(file_primer):    
    ''' 
    This function constructs a dictionary of a primer file
    @param file_primer - type of str 
        The primer file with Locus, Chr, Pos, Strand, Primer, Anchor
        
    @return dict_primer_empt - type of dict
        Dictionary of primer file with pos as key and list of values
    '''
    dict_primer_empty = {}
    if not file_primer:
        raise SystemError("Error: Specify primer file name\n")
    with open(file_primer, 'r') as fh_primer:
        for line in fh_primer:
            (val1Locus, val2Chr, keyPos, val3Strand, val4Primer, val5Anchor) \
                = (line.rstrip('\n')).split('\t')
            if val3Strand == "1":
                val4Primer = reverse_complement(val4Primer)
                val5Anchor = reverse_complement(val5Anchor)
            else:
                pass
            dict_primer_empty[keyPos] = [val1Locus, val2Chr, val3Strand, \
                                         val4Primer, val5Anchor]
    return dict_primer_empty


def dict_for_fastq(file_fastq):
    '''
    This constructs a dictionary of a fastq file
    @param file_fastq - type of str
        The fastq filename
        
    @return - type of dict
        Dictionary of fastq file with seqid as key and seq as values
    '''
    dict_fastq_empty = {}
    if not file_fastq:
        raise SystemError("Error: Specify fastq file name\n")
    n = 4
    with open(file_fastq, 'r') as fh:
         lines = []
         count = 0
         for line in fh:
             lines.append(line.rstrip())
             if len(lines) == n:
                 count += 1
                 ks = ['name', 'sequence', 'optional', 'quality']
                 record = {k: v for k, v in zip(ks, lines)}
                 dict_fastq_empty[record['name'].split(' ')[0]] \
                     = record['sequence']
                 lines = []
         print(count)        
    return dict_fastq_empty


#input primer file
file_primer = "PrimedAnchors.txt"
dict_primer = dict_for_primer(file_primer)


#input fastq files
filedict = getFastqNameR1R2(directory)

# main
for key in filedict:
    '''
    Searches for primer and anchor in reads and pulls out DNA fragment between
    them.
    @return - Output file with information about locus, STRseq fragment, UMI,
        primer, anchor, and respective read countss
    '''
    file_fastq_R1 = key
    file_fastq_R2 = filedict[key]
    dict_fastq_R1 = dict_for_fastq(file_fastq_R1)
    dict_fastq_R2 = dict_for_fastq(file_fastq_R2)
    UmiSTRLociList = []
    counterCS_P_A = 0
    counterCS_P = 0
    counterCS = 0
    counter_noCS_match = 0
    for key in set(dict_fastq_R1) & set(dict_fastq_R2):
        readR1 = dict_fastq_R1[key]
        readR2 = dict_fastq_R2[key]
        if re.match(r'(.{12})(ATTGGAGTCCT)', readR2) is not None:
            counterCS += 1
            for items in dict_primer.items():
                # do fuzzy matching of anchor
                anchor = items[1][4]
                anchorIndex = strfuzzy.fuzzyFind(readR1, anchor, fuzz=1)
                primer = items[1][3]
                if readR1.startswith(primer, 0, len(primer)):
                    counterCS_P += 1
                if ((readR1.startswith(primer, 0, len(primer))) \
                    and (anchorIndex >= 0)):
                    Loci = items[1][0]
                    STRseq =  readR1[len(primer):anchorIndex]
                    searchCS = re.match(r'(.{12})(ATTGGAGTCCT)', readR2)
                    UMI = searchCS.group(1)
                    counterCS_P_A += 1
                    print (counterCS_P_A)
                    UmiSTRLociList.append((Loci, STRseq, UMI, primer, anchor))
        else:
            counter_noCS_match += 1
    
    UmiSTRLociCount = collections.defaultdict(int)       
    for k in UmiSTRLociList:
        UmiSTRLociCount[k] += 1
        
    with open('%s.txt' % (file_fastq_R1[:-6]), 'w') as fh:
        fh.writelines("Number of CS match = %d, Number of Primer match \
                      = %d, Number of Primer and Anchor = %d, \
                      Number of no CS match = %d\n" % (counterCS, \
                          counterCS_P, counterCS_P_A, counter_noCS_match))
        fh.writelines('{}\t{}\n'.format('\t'.join(k),v) for k,v \
                      in UmiSTRLociCount.items())
    

        
